use actix_web::{HttpRequest, web};
use anyhow::anyhow;
use container_common::anyhow_result::AnyhowResult;
use crate::stripe::helpers::common_metadata_keys::{METADATA_EMAIL, METADATA_USER_TOKEN, METADATA_USERNAME};
use crate::stripe::http_endpoints::checkout::create::stripe_create_checkout_session_error::CreateCheckoutSessionError;
use crate::stripe::stripe_config::StripeConfig;
use crate::stripe::traits::internal_product_to_stripe_lookup::{InternalProductToStripeLookup, StripeProduct};
use crate::stripe::traits::internal_user_lookup::{InternalUserLookup, UserMetadata};
use log::{error, warn};
use sqlx::MySqlPool;
use std::collections::HashMap;
use std::str::FromStr;
use stripe::{CheckoutSession, CheckoutSessionMode, CreateCheckoutSession, CreateCheckoutSessionAutomaticTax, CreateCheckoutSessionLineItems, CreateCheckoutSessionPaymentIntentData, CreateCheckoutSessionSubscriptionData, CustomerId, ParseIdError};

/// Create a checkout session and return the URL
/// If anything fails, treat it as a 500 server error.
pub async fn stripe_create_checkout_session_shared(
  maybe_internal_product_key: Option<&str>,
  http_request: &HttpRequest,
  stripe_config: &StripeConfig,
  stripe_client: &stripe::Client,
  internal_product_to_stripe_lookup: &dyn InternalProductToStripeLookup,
  internal_user_lookup: &dyn InternalUserLookup,

) -> Result<String, CreateCheckoutSessionError> {
  let internal_product_key = match maybe_internal_product_key {
    None => return Err(CreateCheckoutSessionError::BadRequest),
    Some(internal_product_key) => internal_product_key,
  };

  let stripe_product = internal_product_to_stripe_lookup
      .lookup_stripe_product_from_internal_product_key(internal_product_key)
      .map_err(|err| {
        error!("Error looking up product: {:?}", err);
        CreateCheckoutSessionError::ServerError // NB: This was probably *our* fault.
      })?
      .ok_or(CreateCheckoutSessionError::PlanNotFound)?; // Non-existing product

  let maybe_user_metadata = internal_user_lookup
      .lookup_user_from_http_request(http_request)
      .await
      .map_err(|err| {
        error!("Error looking up user: {:?}", err);
        CreateCheckoutSessionError::ServerError // NB: This was probably *our* fault.
      })?;

  // NB: Our integration relies on an internal user token being present.
  let user_metadata = match maybe_user_metadata {
    None => return Err(CreateCheckoutSessionError::InvalidSession),
    Some(user_metadata) => user_metadata,
  };

  let success_url  = stripe_config.checkout.success_url
      .as_deref()
      .ok_or(CreateCheckoutSessionError::ServerError)?;

  let cancel_url = stripe_config.checkout.cancel_url
      .as_deref()
      .ok_or(CreateCheckoutSessionError::ServerError)?;

  let checkout_session = {
    let mut params = CreateCheckoutSession::new(
      cancel_url,
      success_url,
    );

    // `client_reference_id`
    // Stripe Docs:
    //   A unique string to reference the Checkout Session.
    //   This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session
    //   with your internal systems.
    //
    // Our Notes:
    //   This gets reported back in the Checkout Session (and related webhooks) as
    //   `client_reference_id`. Passing the same ID on multiple checkouts does not unify or
    //   cross-correlate customers and only seems to be metadata for the checkout session itself.
    //   This is probably only useful for tracking checkout session engagement.
    //params.client_reference_id = Some("SOME_INTERNAL_ID");

    // `customer_email`
    // Stripe Docs:
    //   If provided, this value will be used when the Customer object is created. If not provided,
    //   customers will be asked to enter their email address. Use this parameter to prefill
    //   customer data if you already have an email on file. To access information about the
    //   customer once a session is complete, use the customer field.
    //
    // Our Notes:
    //   This does not look up previous customers with the same email and will not unify or
    //   cross-correlate customers. By default the field will be un-editable in the checkout flow
    //   if this is specified.
    //params.customer_email = Some("email@example.com");

    let mut metadata = HashMap::new();

    metadata.insert(METADATA_USER_TOKEN.to_string(), user_metadata.user_token.to_string());

    if let Some(username) = user_metadata.username.as_deref() {
      metadata.insert(METADATA_USERNAME.to_string(), username.to_string());
    }
    if let Some(user_email) = user_metadata.user_email.as_deref() {
      metadata.insert(METADATA_EMAIL.to_string(), user_email.to_string());
    }

    // NB: This metadata attaches to Stripe's Checkout Session object.
    // This does not attach to the subscription or payment intent, which have their own metadata
    // objects. (TODO: Confirm this.)
    params.metadata = Some(metadata.clone());

    if stripe_product.is_subscription_product {
      // Subscription mode: Use Stripe Billing to set up fixed-price subscriptions.
      params.mode = Some(CheckoutSessionMode::Subscription);

      // NB: This metadata attaches to the subscription entity itself.
      // This cannot be used for non-subscription, one-off payments.
      // https://support.stripe.com/questions/using-metadata-with-checkout-sessions
      params.subscription_data = Some(CreateCheckoutSessionSubscriptionData {
        metadata,
        ..Default::default()
      });

    } else {
      // Payment mode: Accept one-time payments for cards, iDEAL, and more.
      params.mode = Some(CheckoutSessionMode::Payment);

      // NB: This metadata attaches to the payment_intent entity itself.
      // This cannot be used for subscriptions.
      // https://support.stripe.com/questions/using-metadata-with-checkout-sessions
      params.payment_intent_data = Some(CreateCheckoutSessionPaymentIntentData {
        metadata: metadata.clone(),
        ..Default::default()
      });
    }

    params.automatic_tax = Some(CreateCheckoutSessionAutomaticTax { enabled: true });

    params.line_items = Some(vec![
      CreateCheckoutSessionLineItems {
        price: Some(stripe_product.stripe_price_id.to_string()),
        quantity: Some(1),
        ..Default::default()
      }
    ]);

    // If we already have a Stripe customer associated with the user account, we'll reuse it.
    if let Some(existing_stripe_customer_id) = user_metadata.maybe_existing_stripe_customer_id.as_deref() {
      match CustomerId::from_str(existing_stripe_customer_id) {
        Ok(customer_id) => {
          params.customer = Some(customer_id);
        }
        Err(err) => {
          // NB: Don't block checkout.
          warn!("Error parsing user's ({}) supposed existing stripe customer id: {:?}",
            &user_metadata.user_token,
            err);
        }
      }
    }

    CheckoutSession::create(&stripe_client, params)
        .await
        .map_err(|e| {
          error!("Error: {:?}", e);
          CreateCheckoutSessionError::StripeError
        })?
  };

  checkout_session.url.ok_or(CreateCheckoutSessionError::ServerError)
}

#[cfg(test)]
mod tests {
  use actix_web::error::UrlencodedError::ContentType;
  use crate::stripe::http_endpoints::checkout::create::stripe_create_checkout_session_error::CreateCheckoutSessionError;
  use crate::stripe::http_endpoints::checkout::create::stripe_create_checkout_session_shared::stripe_create_checkout_session_shared;
  use crate::stripe::stripe_config::{StripeCheckout, StripeConfig, StripeSecrets};
  use crate::stripe::traits::internal_product_to_stripe_lookup::{MockInternalProductToStripeLookup, StripeProduct};
  use crate::stripe::traits::internal_user_lookup::{MockInternalUserLookup, UserMetadata};
  use mockall::predicate::*;
  use tokio;

  #[tokio::test]
  async fn test_success_case() {
    let http_request = actix_web::test::TestRequest::default()
        .insert_header(actix_web::http::header::ContentType::json())
        .to_http_request();

    let maybe_internal_product_key = Some("TEST_FAKEYOU_PRODUCT");

    let stripe_config = StripeConfig {
      checkout: StripeCheckout {
        success_url: Some("http://example.com/success".to_string()),
        cancel_url: Some("http://example.com/cancel".to_string()),
      },
      secrets: StripeSecrets {
        publishable_key: None,
        secret_key: Some("sk_test_12345".to_string()), // NB: Expected key format
        secret_webhook_signing_key: Some("fake_test_signing".to_string()),
      }
    };

    // TODO: Mock this somehow? We can't really test this library unless we can get inside it.
    //  Note that this might also fail in CI if the client tries to actually talk to Stripe.com.
    let mut stripe_client= stripe::Client::new("sk_test_12345");

    let mut internal_product_to_stripe_lookup_mock = MockInternalProductToStripeLookup::new();

    internal_product_to_stripe_lookup_mock.expect_lookup_stripe_product_from_internal_product_key()
        .with(eq("TEST_FAKEYOU_PRODUCT"))
        .returning(|_| Ok(Some(StripeProduct {
          stripe_product_id: "TEST_PRODUCT_ID".to_string(),
          stripe_price_id: "TEST_PRICE_ID".to_string(),
          is_subscription_product: true,
        })));

    let mut internal_user_lookup_mock = MockInternalUserLookup::new();

    internal_user_lookup_mock.expect_lookup_user_from_http_request()
        .returning(|_| Ok(Some(UserMetadata {
          user_token: "U:USER".to_string(),
          username: Some("vegito".to_string()),
          user_email: Some("vegito@fakeyou.com".to_string()),
          maybe_existing_stripe_customer_id: None,
        })));

    let result = stripe_create_checkout_session_shared(
      maybe_internal_product_key,
      &http_request,
      &stripe_config,
      &stripe_client,
      &internal_product_to_stripe_lookup_mock,
      &internal_user_lookup_mock,
    ).await;

    // TODO: Sort of throwing my hands up over testing this.
    //  There's no convenient way to test which arguments get sent.
    assert_eq!(result, Err(CreateCheckoutSessionError::StripeError));
  }
}
