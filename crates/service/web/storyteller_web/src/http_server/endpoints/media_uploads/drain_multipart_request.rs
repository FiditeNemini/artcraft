use actix_multipart::Field;
use actix_multipart::Multipart;
use actix_web::web::BytesMut;
use container_common::anyhow_result::AnyhowResult;
use crate::http_server::web_utils::read_multipart_field_bytes::{checked_read_multipart_bytes, read_multipart_field_as_text};
use futures::TryStreamExt;
use log::warn;

pub struct UploadMediaRequest {
  pub uuid_idempotency_token: Option<String>,
  pub file_name: Option<String>,
  pub file_bytes: Option<BytesMut>,
}

/// Pull common parts out of multipart media HTTP requests, typically for handling file uploads.
pub async fn drain_multipart_request(mut multipart_payload: Multipart) -> AnyhowResult<UploadMediaRequest> {
  let mut uuid_idempotency_token = None;
  let mut file_bytes = None;
  let mut file_name = None;

  while let Ok(Some(mut field)) = multipart_payload.try_next().await {
    let mut field_name = None;
    let mut field_filename = None;

    if let Some(content_disposition) = field.content_disposition() {
      field_name = content_disposition.get_name()
          .map(|s| s.to_string());
      field_filename = content_disposition.get_filename() // NB: Only used for the file bytes.
          .map(|s| s.to_string());
    }

    match field_name.as_deref() {
      Some("uuid_idempotency_token") => {
        uuid_idempotency_token = read_multipart_field_as_text(&mut field).await
            .map_err(|e| {
              warn!("Error reading idempotency token: {:}", e);
              e
            })?;
      },
      Some("file_bytes") => {
        file_name = field_filename.clone();
        file_bytes = checked_read_multipart_bytes(&mut field).await
            .map_err(|e| {
              warn!("Error reading audio upload: {:}", e);
              e
            })?;
      },
      _ => continue,
    }
  }

  Ok(UploadMediaRequest {
    uuid_idempotency_token,
    file_name,
    file_bytes,
  })
}
