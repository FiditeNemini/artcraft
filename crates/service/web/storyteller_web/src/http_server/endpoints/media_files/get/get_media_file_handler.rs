use std::fmt;
use std::sync::Arc;

use actix_web::{HttpMessage, HttpRequest, HttpResponse, web};
use actix_web::error::ResponseError;
use actix_web::http::StatusCode;
use actix_web::web::Path;
use chrono::{DateTime, Utc};
use log::warn;
use utoipa::ToSchema;

use buckets::public::media_files::bucket_file_path::MediaFileBucketPath;
use enums::by_table::media_files::media_file_animation_type::MediaFileAnimationType;
use enums::by_table::media_files::media_file_class::MediaFileClass;
use enums::by_table::media_files::media_file_engine_category::MediaFileEngineCategory;
use enums::by_table::media_files::media_file_subtype::MediaFileSubtype;
use enums::by_table::media_files::media_file_type::MediaFileType;
use enums::by_table::model_weights::weights_category::WeightsCategory;
use enums::by_table::model_weights::weights_types::WeightsType;
use enums::common::visibility::Visibility;
use enums::no_table::style_transfer::style_transfer_name::StyleTransferName;
use mysql_queries::queries::media_files::get::get_media_file::get_media_file;
use mysql_queries::queries::tts::tts_results::query_tts_result::select_tts_result_by_token;
use tokens::tokens::batch_generations::BatchGenerationToken;
use tokens::tokens::media_files::MediaFileToken;
use tokens::tokens::model_weights::ModelWeightToken;
use tokens::tokens::prompts::PromptToken;
use users_component::common_responses::user_details_lite::UserDetailsLight;

use crate::http_server::common_responses::media_file_cover_image_details::{MediaFileCoverImageDetails, MediaFileDefaultCover};
use crate::http_server::common_responses::simple_entity_stats::SimpleEntityStats;
use crate::http_server::web_utils::response_error_helpers::to_simple_json_error;
use crate::server_state::ServerState;

/// For the URL PathInfo
#[derive(Deserialize, ToSchema)]
pub struct GetMediaFilePathInfo {
  token: MediaFileToken,
}

#[derive(Serialize, ToSchema)]
pub struct GetMediaFileSuccessResponse {
  pub success: bool,
  pub media_file: MediaFileInfo,
}

#[derive(Serialize, ToSchema)]
pub struct MediaFileInfo {
  pub token: MediaFileToken,

  /// The coarse-grained class of media file: image, video, etc.
  pub media_class: MediaFileClass,

  /// Type of media will dictate which fields are populated and what
  /// the frontend should display (eg. video player vs audio player).
  /// This is closer in meaning to a "mime type".
  pub media_type: MediaFileType,

  /// If this is an engine/3D asset, this is the broad category (scene,
  /// animation, etc.) of that object.
  /// This can also be used for filtering in list/batch endpoints.
  pub maybe_engine_category: Option<MediaFileEngineCategory>,

  /// If this is an engine/3D asset for an animation or a rig that can
  /// be animated with either (or both) skeletal or blend shape animations,
  /// this describes the animation regime used or supported.
  pub maybe_animation_type: Option<MediaFileAnimationType>,

  /// If the media file has a subtype, we'll report it.
  /// This is mostly used for Bevy engine files.
  #[deprecated(note="This was for the Bevy engine. Do not use.")]
  pub maybe_media_subtype: Option<MediaFileSubtype>,

  /// Extension for the engine to load over remote:// URLs.
  #[deprecated(note="This was for the Bevy engine. Do not use.")]
  pub maybe_engine_extension: Option<String>,

  /// If the file was generated as part of a batch, this is the token for the batch.
  pub maybe_batch_token: Option<BatchGenerationToken>,

  /// URL to the media file
  pub public_bucket_path: String,

  /// Information about the cover image. Many media files do not require a cover image,
  /// e.g. image files, video files with thumbnails, audio files, etc.
  /// 3D files require them.
  pub cover_image: MediaFileCoverImageDetails,

  //// Provenance Data
  //pub origin_product: MediaFileOriginProductCategory,
  //pub origin_category: MediaFileOriginCategory,
  //pub maybe_origin_model_type: Option<MediaFileOriginModelType>,
  //pub maybe_origin_model_token: Option<String>,
  //pub maybe_origin_filename: Option<String>,

  /// Possible model info (if generated by inference)
  pub maybe_model_weight_info: Option<GetMediaFileModelInfo>,

  /// User info
  pub maybe_creator_user: Option<UserDetailsLight>,

  pub creator_set_visibility: Visibility,

  /// The name or title of the media file (optional)
  pub maybe_title: Option<String>,

  /// Text transcripts for TTS, etc.
  pub maybe_text_transcript: Option<String>,

  /// For Comfy / Video Style Transfer jobs, this might include
  /// the name of the selected style.
  pub maybe_style_name: Option<StyleTransferName>,

  /// For Comfy / Video Style Transfer jobs, this indicates use of face detailer.
  pub used_face_detailer: bool,

  /// For Comfy / Video Style Transfer jobs, this indicates use of upscaling.
  pub used_upscaler: bool,

  /// The foreign key to the prompt used to generate the media, if applicable.
  pub maybe_prompt_token: Option<PromptToken>,

  /// The original filename for uploaded files, if they were provided.
  /// In the future we'll provide our own internal optional filenames.
  pub maybe_original_filename: Option<String>,

  /// Duration for audio and video files, if available.
  /// Measured in milliseconds.
  pub maybe_duration_millis: Option<u64>,

  /// We can simulate media files for "tts_results" records.
  /// If this is set as true, this informs the frontend and API callers not to treat
  /// the token as a media file and improperly assume it can be used with the rest of
  /// the media file APIs.
  pub is_emulated_media_file: bool,

  /// Whether the media file is featured by staff (the featured_items API) or not.
  pub is_featured: bool,

  /// Statistics about the media file
  pub stats: SimpleEntityStats,

  pub created_at: DateTime<Utc>,
  pub updated_at: DateTime<Utc>,

  //pub maybe_moderator_fields: Option<ModeratorFields>,
}

//#[derive(Serialize)]
//pub struct ModeratorFields {
//  pub creator_ip_address: String,
//  pub creator_is_banned_if_user: bool,
//  pub maybe_creator_deleted_at: Option<DateTime<Utc>>,
//  pub maybe_mod_deleted_at: Option<DateTime<Utc>>,
//}

#[derive(Serialize, ToSchema)]
pub struct GetMediaFileModelInfo {
  pub weight_token: ModelWeightToken,
  pub weight_type: WeightsType,
  pub weight_category: WeightsCategory,
  pub title: String,

  /// Cover images are small descriptive images that can be set for any model.
  /// If a cover image is set, this is the path to the asset.
  pub maybe_cover_image_public_bucket_path: Option<String>,

  /// NB: Technically this shouldn't be a nullable field, but since there are so many
  /// joins we'll relax that this must exist (for now).
  pub maybe_weight_creator: Option<UserDetailsLight>,
}

#[derive(Debug, ToSchema)]
pub enum GetMediaFileError {
  ServerError,
  NotFound,
}

impl ResponseError for GetMediaFileError {
  fn status_code(&self) -> StatusCode {
    match *self {
      GetMediaFileError::ServerError => StatusCode::INTERNAL_SERVER_ERROR,
      GetMediaFileError::NotFound => StatusCode::NOT_FOUND,
    }
  }

  fn error_response(&self) -> HttpResponse {
    let error_reason = match self {
      GetMediaFileError::ServerError => "server error".to_string(),
      GetMediaFileError::NotFound => "not found".to_string(),
    };

    to_simple_json_error(&error_reason, self.status_code())
  }
}

// NB: Not using derive_more::Display since Clion doesn't understand it.
impl fmt::Display for GetMediaFileError {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "{:?}", self)
  }
}

/// Get a single media file by token.
#[utoipa::path(
  get,
  tag = "Media Files",
  path = "/v1/media_files/file/{token}",
  responses(
    (status = 200, description = "Found", body = GetMediaFileSuccessResponse),
    (status = 404, description = "Not found", body = GetMediaFileError),
    (status = 500, description = "Server error", body = GetMediaFileError),
  ),
  params(
    ("path" = GetMediaFilePathInfo, description = "Path for Request")
  )
)]
pub async fn get_media_file_handler(
  http_request: HttpRequest,
  path: Path<GetMediaFilePathInfo>,
  server_state: web::Data<Arc<ServerState>>) -> Result<HttpResponse, GetMediaFileError>
{
  let media_file_token = path.into_inner().token;

  let maybe_user_session = server_state
      .session_checker
      .maybe_get_user_session(&http_request, &server_state.mysql_pool)
      .await
      .map_err(|e| {
        warn!("Session checker error: {:?}", e);
        GetMediaFileError::ServerError
      })?;

  let mut show_deleted_results = false;
  let mut is_moderator = false;

  if let Some(user_session) = maybe_user_session {
    // NB: Moderators can see deleted results.
    // Original creators cannot see them (unless they're moderators!)
    show_deleted_results = user_session.can_delete_other_users_tts_results;
    // Moderators get to see all the fields.
    is_moderator = user_session.can_delete_other_users_tts_results
        || user_session.can_edit_other_users_tts_models;
  }

  // NB(bt,2023-11-27): We're moving TT2 results over to the `media_files` table, originally from
  // the `tts_results_table`. We're emulating media files (for viewing) to support API clients
  // (eg. the AI streamer shows).
  let response = if media_file_token.0.starts_with("TR:") {
    // NB: This is the exceptional case, where we emulate results in the `tts_results` table as media files
    emulate_media_file_with_legacy_tts_result_lookup(&media_file_token, show_deleted_results, &server_state).await?
  } else {
    modern_media_file_lookup(&media_file_token, show_deleted_results, &server_state).await?
  };

  let body = serde_json::to_string(&response)
    .map_err(|e| GetMediaFileError::ServerError)?;

  Ok(HttpResponse::Ok()
    .content_type("application/json")
    .body(body))
}

async fn modern_media_file_lookup(
  media_file_token: &MediaFileToken,
  show_deleted_results: bool,
  server_state: &ServerState,
) -> Result<GetMediaFileSuccessResponse, GetMediaFileError> {

  let result = get_media_file(
    media_file_token,
    show_deleted_results,
    &server_state.mysql_pool
  ).await;

  let result = match result {
    Err(e) => {
      warn!("query error: {:?}", e);
      return Err(GetMediaFileError::ServerError);
    }
    Ok(None) => return Err(GetMediaFileError::NotFound),
    Ok(Some(result)) => result,
  };

  //if let Some(moderator_fields) = result.maybe_moderator_fields.as_ref() {
  //  // NB: The moderator fields will always be present before removal
  //  // We don't want non-mods seeing stuff made by banned users.
  //  if (moderator_fields.model_creator_is_banned || moderator_fields.result_creator_is_banned_if_user)
  //      && !is_moderator{
  //    return Err(GetMediaFileError::NotFound);
  //  }
  //}

  //if !is_moderator {
  //  result.maybe_moderator_fields = None;
  //}

  let public_bucket_path = MediaFileBucketPath::from_object_hash(
    &result.public_bucket_directory_hash,
    result.maybe_public_bucket_prefix.as_deref(),
    result.maybe_public_bucket_extension.as_deref())
      .get_full_object_path_str()
      .to_string();

  let maybe_cover_image_public_bucket_path = match result.maybe_model_cover_image_public_bucket_hash
      .as_deref()
  {
    None => None,
    Some(hash) => Some(MediaFileBucketPath::from_object_hash(
      &hash,
      result.maybe_model_cover_image_public_bucket_prefix.as_deref(),
      result.maybe_model_cover_image_public_bucket_extension.as_deref())
        .get_full_object_path_str()
        .to_string()
    )
  };

  // NB: Some engine pages will need to know the engine extension to load the file.
  let maybe_engine_extension = match result.media_type {
    MediaFileType::Bvh => Some(".bvh".to_string()),
    MediaFileType::Glb => Some(".glb".to_string()),
    MediaFileType::Gltf => Some(".gltf".to_string()),
    MediaFileType::SceneRon => Some(".scn.ron".to_string()),
    _ => None,
  };

  Ok(GetMediaFileSuccessResponse {
    success: true,
    media_file: MediaFileInfo {
      token: result.token.clone(),
      media_class: result.media_class,
      media_type: result.media_type,
      maybe_engine_category: result.maybe_engine_category,
      maybe_animation_type: result.maybe_animation_type,
      maybe_media_subtype: result.maybe_media_subtype,
      maybe_engine_extension,
      maybe_batch_token: result.maybe_batch_token,
      public_bucket_path,
      cover_image: MediaFileCoverImageDetails::from_optional_db_fields(
        &result.token,
        result.maybe_file_cover_image_public_bucket_hash.as_deref(),
        result.maybe_file_cover_image_public_bucket_prefix.as_deref(),
        result.maybe_file_cover_image_public_bucket_extension.as_deref(),
      ),
      maybe_title: result.maybe_title,
      maybe_text_transcript: result.maybe_text_transcript,
      maybe_style_name: result.maybe_prompt_args
          .as_ref()
          .and_then(|args| args.style_name.as_ref())
          .and_then(|style| style.to_style_name()),
      used_face_detailer: result.maybe_prompt_args
          .as_ref()
          .and_then(|args| args.used_face_detailer)
          .unwrap_or(false),
      used_upscaler: result.maybe_prompt_args
          .as_ref()
          .and_then(|args| args.used_upscaler)
          .unwrap_or(false),
      maybe_model_weight_info: match result.maybe_model_weights_token {
        None => None,
        Some(weight_token) => Some(GetMediaFileModelInfo {
          weight_token,
          // TODO(bt,2023-12-28): Instead of giving bogus defaults on None, make these optional or return
          //  None for *everything* on any field being absent.
          weight_type: result.maybe_model_weights_type.unwrap_or(WeightsType::Tacotron2),
          weight_category: result.maybe_model_weights_category.unwrap_or(WeightsCategory::TextToSpeech),
          title: result.maybe_model_weights_title.unwrap_or_else(|| "model".to_string()),
          maybe_cover_image_public_bucket_path,
          maybe_weight_creator: UserDetailsLight::from_optional_db_fields_owned(
            result.maybe_model_weight_creator_user_token,
            result.maybe_model_weight_creator_username,
            result.maybe_model_weight_creator_display_name,
            result.maybe_model_weight_creator_gravatar_hash,
          ),
        })
      },
      maybe_creator_user: UserDetailsLight::from_optional_db_fields_owned(
        result.maybe_creator_user_token,
        result.maybe_creator_username,
        result.maybe_creator_display_name,
        result.maybe_creator_gravatar_hash,
      ),
      creator_set_visibility: result.creator_set_visibility,
      maybe_prompt_token: result.maybe_prompt_token,
      maybe_original_filename: result.maybe_origin_filename,
      maybe_duration_millis: result.maybe_duration_millis,
      is_emulated_media_file: false,
      is_featured: result.is_featured,
      stats: SimpleEntityStats {
        positive_rating_count: result.maybe_ratings_positive_count.unwrap_or(0),
        bookmark_count: result.maybe_bookmark_count.unwrap_or(0),
      },
      created_at: result.created_at,
      updated_at: result.updated_at,
    },
  })
}

async fn emulate_media_file_with_legacy_tts_result_lookup(
  media_file_token: &MediaFileToken,
  show_deleted_results: bool,
  server_state: &ServerState,
) -> Result<GetMediaFileSuccessResponse, GetMediaFileError> {

  let result = select_tts_result_by_token(
    &media_file_token.as_str(),
    show_deleted_results,
    &server_state.mysql_pool
  ).await;

  let result = match result {
    Err(e) => {
      warn!("query error (legacy TTS): {:?}", e);
      return Err(GetMediaFileError::ServerError);
    }
    Ok(None) => return Err(GetMediaFileError::NotFound),
    Ok(Some(result)) => result,
  };

  //if let Some(moderator_fields) = result.maybe_moderator_fields.as_ref() {
  //  // NB: The moderator fields will always be present before removal
  //  // We don't want non-mods seeing stuff made by banned users.
  //  if (moderator_fields.model_creator_is_banned || moderator_fields.result_creator_is_banned_if_user)
  //      && !is_moderator{
  //    return Err(GetMediaFileError::NotFound);
  //  }
  //}

  //if !is_moderator {
  //  result.maybe_moderator_fields = None;
  //}

  // NB: TTS results receive the legacy treatment where their table only reports the full bucket path
  let public_bucket_path = result.public_bucket_wav_audio_path.clone();

  // NB: NOT A MEDIA FILE TOKEN, but should be fine. API callers can't pass this around to other
  // media file endpoints (unless we want to emulate the behavior in all endpoints, which we don't)
  let token = MediaFileToken::new_from_str(&result.tts_result_token);

  Ok(GetMediaFileSuccessResponse {
    success: true,
    media_file: MediaFileInfo {
      token,
      media_class: MediaFileClass::Audio, // NB: Always audio
      media_type: MediaFileType::Audio, // NB: Always audio
      maybe_engine_category: None,
      maybe_animation_type: None,
      maybe_media_subtype: None,
      maybe_engine_extension: None,
      maybe_batch_token: None,
      public_bucket_path,
      cover_image: MediaFileCoverImageDetails::from_token_str(&result.tts_result_token),
      maybe_model_weight_info: Some(GetMediaFileModelInfo {
        // NB: These should be reasonable synthetic defaults for emulated TT2 results, even the "ModelWeightToken".
        weight_token: ModelWeightToken::new_from_str(&result.tts_model_token),
        weight_type: WeightsType::Tacotron2,
        weight_category: WeightsCategory::TextToSpeech,
        title: result.tts_model_title.unwrap_or_else(|| "tacotron2 model".to_string()),
        maybe_cover_image_public_bucket_path: None,
        maybe_weight_creator: None, // NB: Not worth the trouble of synthesizing this
      }),
      maybe_creator_user: UserDetailsLight::from_optional_db_fields_owned(
        result.maybe_creator_user_token,
        result.maybe_creator_username,
        result.maybe_creator_display_name,
        result.maybe_creator_gravatar_hash,
      ),
      maybe_prompt_token: None,
      maybe_style_name: None,
      used_face_detailer: false,
      used_upscaler: false,
      creator_set_visibility: result.creator_set_visibility,
      maybe_title: None,
      maybe_text_transcript: Some(result.raw_inference_text),
      maybe_original_filename: None,
      maybe_duration_millis: None,
      is_emulated_media_file: true,
      is_featured: false,
      stats: SimpleEntityStats {
        positive_rating_count: 0,
        bookmark_count: 0,
      },
      created_at: result.created_at,
      updated_at: result.updated_at,
    },
  })
}
