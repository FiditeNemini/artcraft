use crate::api_error::ApiError;
use crate::shared_response_types::media_file_cover_image_details::MediaFileCoverImageDetails;
use crate::shared_response_types::media_links::MediaLinks;
use crate::shared_response_types::simple_entity_stats::SimpleEntityStats;
use crate::shared_response_types::user_details_light::UserDetailsLight;
use crate::utils::api_host::ApiHost;
use crate::utils::filter_bad_response::filter_bad_response;
use crate::utils::http_get_anonymous::http_get_anonymous;
use chrono::{DateTime, Utc};
use enums::by_table::media_files::media_file_animation_type::MediaFileAnimationType;
use enums::by_table::media_files::media_file_class::MediaFileClass;
use enums::by_table::media_files::media_file_engine_category::MediaFileEngineCategory;
use enums::by_table::media_files::media_file_type::MediaFileType;
use enums::by_table::model_weights::weights_category::WeightsCategory;
use enums::common::visibility::Visibility;
use enums::no_table::style_transfer::style_transfer_name::StyleTransferName;
use enums_public::by_table::model_weights::public_weights_types::PublicWeightsType;
use log::debug;
use serde_derive::Deserialize;
use tokens::tokens::batch_generations::BatchGenerationToken;
use tokens::tokens::media_files::MediaFileToken;
use tokens::tokens::model_weights::ModelWeightToken;
use tokens::tokens::prompts::PromptToken;

/// Get details about a media file from our backend
pub async fn get_media_file(api_host: &ApiHost, media_file_token: &MediaFileToken) -> Result<GetMediaFileSuccessResponse, ApiError> {
  let url = get_media_file_token_route(api_host, media_file_token);

  debug!("Requesting {:?}", &url);

  let response = http_get_anonymous(url).await?;
  let response = filter_bad_response(response).await?;
  let response_body = &response.text().await?;

  let media_file = serde_json::from_str(&response_body)?;

  Ok(media_file)
}

fn get_media_file_token_route(api_host: &ApiHost, media_file_token: &MediaFileToken) -> String {
  let api_hostname = api_host.to_api_hostname();
  let media_file_token = media_file_token.as_str();
  format!("https://{}/v1/media_files/file/{}", api_hostname, media_file_token)
}

// TODO(bt,2025-04-22): Share API definitions between client and server in common crate.

#[derive(Deserialize, Debug)]
pub struct GetMediaFileSuccessResponse {
  pub success: bool,
  pub media_file: MediaFileInfo,
}

#[derive(Deserialize, Debug)]
pub struct MediaFileInfo {
  pub token: MediaFileToken,

  /// The coarse-grained class of media file: image, video, etc.
  pub media_class: MediaFileClass,

  /// Type of media will dictate which fields are populated and what
  /// the frontend should display (eg. video player vs audio player).
  /// This is closer in meaning to a "mime type".
  pub media_type: MediaFileType,

  /// If this is an engine/3D asset, this is the broad category (scene,
  /// animation, etc.) of that object.
  /// This can also be used for filtering in list/batch endpoints.
  pub maybe_engine_category: Option<MediaFileEngineCategory>,

  /// If this is an engine/3D asset for an animation or a rig that can
  /// be animated with either (or both) skeletal or blend shape animations,
  /// this describes the animation regime used or supported.
  pub maybe_animation_type: Option<MediaFileAnimationType>,

  //  /// If the media file has a subtype, we'll report it.
  //  /// This is mostly used for Bevy engine files.
  //  #[deprecated(note="This was for the Bevy engine. Do not use.")]
  //  pub maybe_media_subtype: Option<MediaFileSubtype>,

  //  /// Extension for the engine to load over remote:// URLs.
  //  #[deprecated(note="This was for the Bevy engine. Do not use.")]
  //  pub maybe_engine_extension: Option<String>,

  /// If the file was generated as part of a batch, this is the token for the batch.
  pub maybe_batch_token: Option<BatchGenerationToken>,

  /// If this media file was generated by a scene from the engine, this is a
  /// link to that file.
  pub maybe_scene_source_media_file_token: Option<MediaFileToken>,

  //  /// (DEPRECATED) URL path to the media file
  //  #[deprecated(note="This field doesn't point to the full URL. Use media_links instead to leverage the CDN.")]
  //  pub public_bucket_path: String,

  //  /// (DEPRECATED) Full URL to the media file
  //  #[deprecated(note="This points to the bucket. Use media_links instead to leverage the CDN.")]
  //  pub public_bucket_url: Url,

  /// Rich CDN links to the media, including thumbnails, previews, and more.
  pub media_links: MediaLinks,

  /// Information about the cover image. Many media files do not require a cover image,
  /// e.g. image files, video files with thumbnails, audio files, etc.
  /// 3D files require them.
  pub cover_image: MediaFileCoverImageDetails,

  //// Provenance Data
  //pub origin_product: MediaFileOriginProductCategory,
  //pub origin_category: MediaFileOriginCategory,
  //pub maybe_origin_model_type: Option<MediaFileOriginModelType>,
  //pub maybe_origin_model_token: Option<String>,
  //pub maybe_origin_filename: Option<String>,

  /// Possible model info (if generated by inference)
  pub maybe_model_weight_info: Option<GetMediaFileModelInfo>,

  /// User info
  pub maybe_creator_user: Option<UserDetailsLight>,

  pub creator_set_visibility: Visibility,

  /// The file was uploaded by the user.
  /// This does not include files generated on the client side, like studio renders.
  pub is_user_upload: bool,

  /// The file was created by the system.
  /// This includes files generated on the client side, like studio renders.
  pub is_intermediate_system_file: bool,

  /// The name or title of the media file (optional)
  pub maybe_title: Option<String>,

  /// Text transcripts for TTS, etc.
  pub maybe_text_transcript: Option<String>,

  //  /// OPTIONAL. Details on live portrait generated media files,
  //  /// if this is a live portrait generated file.
  //  pub maybe_live_portrait_details: Option<MediaFileLivePortraitDetails>,

  /// For Comfy / Video Style Transfer jobs, this might include
  /// the name of the selected style.
  pub maybe_style_name: Option<StyleTransferName>,

  /// For Comfy / Video Style Transfer jobs, this indicates use of face detailer.
  pub used_face_detailer: bool,

  /// For Comfy / Video Style Transfer jobs, this indicates use of upscaling.
  pub used_upscaler: bool,

  /// The foreign key to the prompt used to generate the media, if applicable.
  pub maybe_prompt_token: Option<PromptToken>,

  /// The original filename for uploaded files, if they were provided.
  /// In the future we'll provide our own internal optional filenames.
  pub maybe_original_filename: Option<String>,

  /// Duration for audio and video files, if available.
  /// Measured in milliseconds.
  pub maybe_duration_millis: Option<u64>,

  /// We can simulate media files for "tts_results" records.
  /// If this is set as true, this informs the frontend and API callers not to treat
  /// the token as a media file and improperly assume it can be used with the rest of
  /// the media file APIs.
  pub is_emulated_media_file: bool,

  /// Whether the media file is featured by staff (the featured_items API) or not.
  pub is_featured: bool,

  /// Statistics about the media file
  pub stats: SimpleEntityStats,

  pub created_at: DateTime<Utc>,
  pub updated_at: DateTime<Utc>,

  pub maybe_moderator_fields: Option<GetMediaFileModeratorFields>,
}

#[derive(Deserialize, Debug)]
pub struct GetMediaFileModeratorFields {
  /// This may become public in the future.
  pub maybe_style_transfer_source_media_file_token: Option<MediaFileToken>,
  //pub creator_ip_address: String,
  //pub creator_is_banned_if_user: bool,
  //pub maybe_creator_deleted_at: Option<DateTime<Utc>>,
  //pub maybe_mod_deleted_at: Option<DateTime<Utc>>,
}

#[derive(Deserialize, Debug)]
pub struct GetMediaFileModelInfo {
  pub weight_token: ModelWeightToken,
  pub weight_type: PublicWeightsType,
  pub weight_category: WeightsCategory,
  pub title: String,

  /// Cover images are small descriptive images that can be set for any model.
  /// If a cover image is set, this is the path to the asset.
  pub maybe_cover_image_public_bucket_path: Option<String>,

  /// NB: Technically this shouldn't be a nullable field, but since there are so many
  /// joins we'll relax that this must exist (for now).
  pub maybe_weight_creator: Option<UserDetailsLight>,
}

#[cfg(test)]
mod tests {
  use crate::media_files::get_media_file::get_media_file;
  use crate::utils::api_host::ApiHost;
  use tokens::tokens::media_files::MediaFileToken;

  #[tokio::test]
  #[ignore] // Don't run in CI. Requires valid cookie
  async fn test_request() {
    let host = ApiHost::Storyteller;
    let token = MediaFileToken::new_from_str("m_gff67btr810vg3ng9szj85zskztcgy");
    let result = get_media_file(&host, &token).await.unwrap();

    println!("Result: {:?}", &result);

    assert_eq!(result.success, false); // NB: Will fail so we can see debug printed result.
  }
}
