use enums::by_table::generic_inference_jobs::inference_category::InferenceCategory;
use errors::AnyhowResult;

use crate::payloads::generic_inference_args::lipsync_payload::LipsyncArgs;
use crate::payloads::generic_inference_args::tts_payload::TTSArgs;
use crate::payloads::generic_inference_args::videofilter_payload::RerenderArgs;
use crate::payloads::generic_inference_args::image_generation_payload::SDArgs;

/// Used to encode extra state for the `generic_inference_jobs` table.
/// This should act somewhat like a serialized protobuf stored inside a record.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GenericInferenceArgs {
  /// The category of inference (probably also present in a top-level field)
  #[serde(rename = "cat")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to consume fewer bytes
  #[serde(alias = "inference_category")]
  pub inference_category: Option<InferenceCategoryAbbreviated>,

  /// REQUIRED.
  /// Actual type-specific arguments.
  #[serde(skip_serializing_if = "Option::is_none")]
  pub args: Option<PolymorphicInferenceArgs>,
}

/// Same as `InferenceCategory`, but serialized in fewer characters
/// Do not change the values.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord, PartialOrd, Deserialize, Serialize)]
pub enum InferenceCategoryAbbreviated {
  #[serde(rename = "la")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  #[serde(alias = "lipsync_animation")]
  LipsyncAnimation,

  #[serde(rename = "tts")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  #[serde(alias = "text_to_speech")]
  TextToSpeech,

  #[serde(rename = "vc")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  #[serde(alias = "voice_conversion")]
  VoiceConversion,

  #[serde(rename = "vf")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  #[serde(alias = "video_filter")]
  VideoFilter,

  #[serde(rename = "ig")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  #[serde(alias = "image_generation")]
  ImageGeneration
}

#[derive(Serialize, Deserialize, Clone, Copy, Debug)]
pub enum FundamentalFrequencyMethodForJob {
  #[serde(rename = "r")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  Rmvpe,
  #[serde(rename = "c")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  Crepe,
  #[serde(rename = "d")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  Dio,
  #[serde(rename = "h")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
  Harvest,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum PolymorphicInferenceArgs {
  /// Lipsync Animation (Short name to save  space when serializing)
  /// This is SadTalker, not Wav2Lip.
  La (LipsyncArgs),

  /// Text to speech. (Short name to save space when serializing.)
  Tts(TTSArgs),
    // No arguments yet.
    // It might be best to just not include this when not used.
    
  /// Voice conversion. (Short name to save space when serializing.)
  Vc {
    /// Argument for so-vits-svc
    /// The python model defaults to true, but that sounds awful,
    /// so we default to false unless specified.
    #[serde(rename = "a")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
    #[serde(skip_serializing_if = "Option::is_none")]
    auto_predict_f0: Option<bool>,

    /// Argument for RVC (-fm / --f0_method)
    /// Crepe, dio, harvest, etc.
    /// If unspecified, the model defaults to crepe
    #[serde(rename = "fm")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
    #[serde(skip_serializing_if = "Option::is_none")]
    override_f0_method: Option<FundamentalFrequencyMethodForJob>,

    /// Argument for so-vits-svc (-t / --transpose)
    /// Argument for RVC (--f0_up_key)
    /// Pitch control.
    /// If unspecified, the model uses "0".
    #[serde(rename = "t")] // NB: DO NOT CHANGE. It could break live jobs. Renamed to be fewer bytes.
    #[serde(skip_serializing_if = "Option::is_none")]
    transpose: Option<i32>,
  },

  /// Rerender a video. (Short name to save space when serializing.)
  Rr(RerenderArgs),

  /// Image generation. (Short name to save space when serializing.)
  Ig(SDArgs)
}


impl GenericInferenceArgs {

  pub fn from_json(json: &str) -> AnyhowResult<Self> {
    Ok(serde_json::from_str(json)?)
  }

  pub fn to_json(&self) -> AnyhowResult<String> {
    Ok(serde_json::to_string(self)?)
  }
}

impl InferenceCategoryAbbreviated {
  pub fn from_inference_category(category: InferenceCategory) -> Self {
    match category {
      InferenceCategory::LipsyncAnimation => Self::LipsyncAnimation,
      InferenceCategory::TextToSpeech => Self::TextToSpeech,
      InferenceCategory::VoiceConversion => Self::VoiceConversion,
      InferenceCategory::VideoFilter => Self::VideoFilter,
      InferenceCategory::ImageGeneration => Self::ImageGeneration,
    }
  }

  pub fn to_inference_category(self) -> InferenceCategory {
    match self {
      Self::LipsyncAnimation => InferenceCategory::LipsyncAnimation,
      Self::TextToSpeech => InferenceCategory::TextToSpeech,
      Self::VoiceConversion => InferenceCategory::VoiceConversion,
      Self::VideoFilter => InferenceCategory::VideoFilter,
      Self::ImageGeneration =>InferenceCategory::ImageGeneration
    }
  }
}

#[cfg(test)]
mod tests {
  use enums::by_table::generic_inference_jobs::inference_category;

use crate::payloads::generic_inference_args::generic_inference_args::{FundamentalFrequencyMethodForJob, GenericInferenceArgs, InferenceCategoryAbbreviated, PolymorphicInferenceArgs};
  use crate::payloads::generic_inference_args::lipsync_payload::{LipsyncAnimationAudioSource, LipsyncAnimationImageSource, LipsyncArgs};
  use crate::payloads::generic_inference_args::tts_payload::TTSArgs;
  use crate::payloads::generic_inference_args::image_generation_payload::SDArgs;
  use tokens::tokens::{model_weights::ModelWeightToken, media_files::MediaFileToken};

  #[test]
  fn typical_lipsync_animation_args_serialize() {
    let args = GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::LipsyncAnimation),
      args: Some(PolymorphicInferenceArgs::La(LipsyncArgs {
        maybe_audio_source: Some(LipsyncAnimationAudioSource::U("foo".to_string())),
        maybe_image_source: Some(LipsyncAnimationImageSource::F("bar".to_string())),
        maybe_face_enhancer: None,
        maybe_pose_style: None,
        maybe_preprocess: None,
        maybe_make_still: None,
        maybe_remove_watermark: None,
        maybe_resize_width: None,
        maybe_resize_height: None,
      })),
    };

    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json, r#"{"cat":"la","args":{"La":{"a":{"U":"foo"},"i":{"F":"bar"}}}}"#.to_string());

    // NB: Make sure we don't overflow the DB field capacity (TEXT column).
    assert!(json.len() < 1000);
  }

  #[test]
  fn typical_tts_args_serialize() {
    let args = GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::TextToSpeech),
      args: Some(PolymorphicInferenceArgs::Tts(TTSArgs {
        voice_token: Some("token".to_string()),
        dataset_token: None,
      })),
    };

    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json, r#"{"cat":"tts","args":{"Tts":{"vt":"token"}}}"#.to_string());

    // NB: Make sure we don't overflow the DB field capacity (TEXT column).
    assert!(json.len() < 1000);
  }

  #[test]
  fn typical_image_gen_args_serialize() {

    let video_media_token = MediaFileToken("video_media_token".to_string());
    let image_media_token = MediaFileToken("image_media_token".to_string());
    let sd_model_token = ModelWeightToken("sd_model_token".to_string());
    let lora_model_token = ModelWeightToken("lora_model_token".to_string());

    let prompt = "prompt".to_string();
    let a_prompt = "a_prompt".to_string();
    let n_prompt = "n_prompt".to_string();
    let seed = 1;
    let upload_path = "upload_path".to_string();
    let lora_upload_path = "lora_upload_path".to_string();
    
    let args = GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::ImageGeneration),
      args: Some(PolymorphicInferenceArgs::Ig(SDArgs {
        maybe_video_source: Some(video_media_token),
        maybe_image_source: Some(image_media_token),
        maybe_sd_model_token: Some(sd_model_token),
        maybe_lora_model_token: Some(lora_model_token),
        maybe_prompt: Some(prompt),
        maybe_a_prompt: Some(a_prompt),
        maybe_n_prompt: Some(n_prompt),
        maybe_seed: Some(seed),
        maybe_upload_path: Some(upload_path),
        maybe_lora_upload_path: Some(lora_upload_path)
      })),
    };

    let json = serde_json::ser::to_string(&args).unwrap();
    assert_eq!(json, r#"{"cat":"ig","args":{"Ig":{"vs":"video_media_token","is":"image_media_token","sd":"sd_model_token","lm":"lora_model_token","p":"prompt","ap":"a_prompt","np":"n_prompt","se":1,"mu":"upload_path","lu":"lora_upload_path"}}}"#.to_string());
  }

  #[test]
  fn typical_voice_conversion_args_serialize() {
    let args = GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::VoiceConversion),
      args: Some(PolymorphicInferenceArgs::Vc {
        auto_predict_f0: Some(false),
        override_f0_method: None,
        transpose: None,
      }),
    };

    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json,
      r#"{"cat":"vc","args":{"Vc":{"a":false}}}"#.to_string());

    // NB: Make sure we don't overflow the DB field capacity (TEXT column).
    assert!(json.len() < 1000);
  }

  #[test]
  fn many_voice_conversion_args_serialize() {
    let args = GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::VoiceConversion),
      args: Some(PolymorphicInferenceArgs::Vc {
        auto_predict_f0: Some(false),
        override_f0_method: Some(FundamentalFrequencyMethodForJob::Dio),
        transpose: Some(-1),
      }),
    };

    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json,
               r#"{"cat":"vc","args":{"Vc":{"a":false,"fm":"d","t":-1}}}"#.to_string());

    // NB: Make sure we don't overflow the DB field capacity (TEXT column).
    assert!(json.len() < 1000);
  }

  #[test]
  fn voice_conversion_args_do_not_serialize_none() {
    let args = GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::VoiceConversion),
      args: Some(PolymorphicInferenceArgs::Vc {
        auto_predict_f0: None, // NB: Do not serialize
        override_f0_method: None,
        transpose: None,
      }),
    };

    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json,
               r#"{"cat":"vc","args":{"Vc":{}}}"#.to_string());

    // NB: Make sure we don't overflow the DB field capacity (TEXT column).
    assert!(json.len() < 1000);
  }

  #[test]
  fn serialize_nullable_form() {
    let mut args : Option<GenericInferenceArgs> = None;
    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json, "null");

    args = Some(GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::VoiceConversion),
      args: Some(PolymorphicInferenceArgs::Vc {
        auto_predict_f0: Some(true),
        override_f0_method: None,
        transpose: None,
      }),
    });

    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json,
               r#"{"cat":"vc","args":{"Vc":{"a":true}}}"#.to_string());

    // NB: Make sure we don't overflow the DB field capacity (TEXT column).
    assert!(json.len() < 1000);
  }

  #[test]
  fn rmvpe() {
    let args = GenericInferenceArgs {
      inference_category: Some(InferenceCategoryAbbreviated::VoiceConversion),
      args: Some(PolymorphicInferenceArgs::Vc {
        auto_predict_f0: None,
        override_f0_method: Some(FundamentalFrequencyMethodForJob::Rmvpe),
        transpose: None,
      }),
    };

    let json = serde_json::ser::to_string(&args).unwrap();

    // NB: Assert the serialized form. If this changes and the test breaks, be careful about migrating.
    assert_eq!(json,
               r#"{"cat":"vc","args":{"Vc":{"fm":"r"}}}"#.to_string());

    // NB: Make sure we don't overflow the DB field capacity (TEXT column).
    assert!(json.len() < 1000);
  }
}
