use anyhow::anyhow;
use log::error;
use sqlx::{Executor, MySql};
use sqlx::Error::Database;

use errors::AnyhowResult;

/// Insert an idempotency token (typically a UUID generated by the frontend) to make sure the
/// frontend doesn't retry the same request by mistake. There's a unique index on idempotency
/// tokens, so any retries with the same value will fail.
pub async fn insert_idempotency_token<'e, 'c, E>(
  idempotency_token: &'e str,
  mysql_executor: E,
) -> AnyhowResult<()>
  where E: 'e + Executor<'c, Database=MySql>
{
  let query = sqlx::query!(
    r#"INSERT INTO idempotency_tokens SET idempotency_value = ?"#,
    idempotency_token);

  let query_result = query.execute(mysql_executor).await;

  match query_result {
    Ok(_res) => Ok(()),
    Err(err) => {
      error!("error inserting idempotency token: {:?}", err);
      // NB: SQLSTATE[23000]: Integrity constraint violation
      // NB: MySQL Error Code 1062: Duplicate key insertion (this is harder to access)
      match err {
        Database(ref err) => {
          let _maybe_code = err.code().map(|c| c.into_owned());
        },
        _ => {},
      }
      Err(anyhow!("error inserting idempotency token: {:?}", err))
    }
  }
}
